{"version":3,"sources":["webpack://ReactContexify/webpack/universalModuleDefinition","webpack://ReactContexify/webpack/bootstrap","webpack://ReactContexify/./src/components/constants.ts","webpack://ReactContexify/external \"react\"","webpack://ReactContexify/./src/index.ts","webpack://ReactContexify/./src/components/VirtualList.tsx","webpack://ReactContexify/./src/components/SizeAndPositionManager.ts"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__1__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","DIRECTION","ALIGNMENT","SCROLL_CHANGE_REASON","scrollProp","sizeProp","positionProp","VERTICAL","HORIZONTAL","marginProp","oppositeMarginProp","default","STYLE_WRAPPER","overflow","willChange","WebkitOverflowScrolling","STYLE_INNER","position","width","minHeight","STYLE_ITEM","top","left","STYLE_STICKY_ITEM","props","setState","estimatedItemSize","height","itemCount","itemSize","onItemsRendered","onScroll","overscanCount","renderItem","scrollDirection","scrollOffset","scrollToAlignment","scrollToIndex","stickyIndices","style","forceUpdate","rootNodeRef","useRef","styleCacheRef","itemCountRef","itemSizeGetter","index","Array","isArray","getSize","getEstimatedItemSize","sizeAndPositionManager","getOffsetForIndex","newScrollToAlignment","newItemCount","getUpdatedOffsetForIndex","align","containerSize","Number","currentOffset","offset","targetIndex","setOffset","scrollChangeReason","setScrollChangeReason","scrollTo","current","handleScroll","event","newOffset","target","OBSERVED","useEffect","addEventListener","passive","removeEventListener","recomputeSizes","startIndex","resetItem","updateConfig","REQUESTED","getStyle","sticky","size","zIndex","start","stop","items","wrapperStyle","innerStyle","getTotalSize","length","forEach","push","display","includes","stopIndex","ref","rest","this","itemSizeAndPositionData","lastMeasuredIndex","getLastMeasuredIndex","getSizeAndPositionForIndex","Error","lastMeasuredSizeAndPosition","getSizeAndPositionOfLastMeasuredItem","isNaN","idealOffset","datum","maxOffset","minOffset","END","CENTER","START","Math","max","min","totalSize","getVisibleRange","findNearestItem","binarySearch","high","low","exponentialSearch","middle","floor","interval"],"mappings":"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","file":"ReactContexify.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactContexify\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"ReactContexify\"] = factory(root[\"react\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__1__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","export enum ALIGNMENT {\r\n  AUTO = 'auto',\r\n  START = 'start',\r\n  CENTER = 'center',\r\n  END = 'end'\r\n}\r\n\r\nexport enum DIRECTION {\r\n  HORIZONTAL = 'horizontal',\r\n  VERTICAL = 'vertical'\r\n}\r\n\r\nexport enum SCROLL_CHANGE_REASON {\r\n  OBSERVED = 'observed',\r\n  REQUESTED = 'requested'\r\n}\r\n\r\n// export const scrollProp = {\r\n//   [DIRECTION.VERTICAL]: 'scrollTop',\r\n//   [DIRECTION.HORIZONTAL]: 'scrollLeft',\r\n// };\r\n\r\n// export const scrollProp = {\r\n//   vertical: \"scrollTop\",\r\n//   horizontal: \"scrollLeft\"\r\n// };\r\n\r\nexport enum scrollProp {\r\n  vertical = 'scrollTop',\r\n  horizontal = 'scrollLeft'\r\n}\r\n\r\n// export const sizeProp = {\r\n//   [DIRECTION.VERTICAL]: \"height\",\r\n//   [DIRECTION.HORIZONTAL]: \"width\"\r\n// };\r\n\r\n// export const sizeProp = {\r\n//   vertical: \"height\",\r\n//   horizontal: \"width\"\r\n// };\r\n\r\nexport enum sizeProp {\r\n  vertical = 'height',\r\n  horizontal = 'width'\r\n}\r\n\r\nexport const positionProp = {\r\n  [DIRECTION.VERTICAL]: 'top',\r\n  [DIRECTION.HORIZONTAL]: 'left'\r\n};\r\n\r\nexport const marginProp = {\r\n  [DIRECTION.VERTICAL]: 'marginTop',\r\n  [DIRECTION.HORIZONTAL]: 'marginLeft'\r\n};\r\n\r\nexport const oppositeMarginProp = {\r\n  [DIRECTION.VERTICAL]: 'marginBottom',\r\n  [DIRECTION.HORIZONTAL]: 'marginRight'\r\n};\r\n","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","export { default as VirtualList } from './components/VirtualList';\nexport { ItemStyle } from './components/VirtualList';\nexport { ALIGNMENT } from './components/constants';\n","import * as React from 'react';\r\nimport { useRef, useState, useEffect, CSSProperties } from 'react';\r\nimport SizeAndPositionManager, { ItemSize } from './SizeAndPositionManager';\r\nimport {\r\n  ALIGNMENT,\r\n  DIRECTION,\r\n  SCROLL_CHANGE_REASON,\r\n  marginProp,\r\n  oppositeMarginProp,\r\n  positionProp,\r\n  scrollProp,\r\n  sizeProp\r\n} from './constants';\r\n\r\nexport { DIRECTION as ScrollDirection } from './constants';\r\n\r\nexport type ItemPosition = 'absolute' | 'sticky';\r\n\r\nexport interface ItemStyle {\r\n  position: ItemPosition;\r\n  top?: number;\r\n  left: number;\r\n  width: string | number;\r\n  height?: number;\r\n  marginTop?: number;\r\n  marginLeft?: number;\r\n  marginRight?: number;\r\n  marginBottom?: number;\r\n  zIndex?: number;\r\n}\r\n\r\ninterface StyleCache {\r\n  [id: number]: ItemStyle;\r\n}\r\n\r\nexport interface ItemInfo {\r\n  index: number;\r\n  style: ItemStyle;\r\n}\r\n\r\nexport interface RenderedRows {\r\n  startIndex: number;\r\n  stopIndex: number;\r\n}\r\n\r\nexport interface Props {\r\n  className?: string;\r\n  estimatedItemSize?: number;\r\n  height: number | string;\r\n  itemCount: number;\r\n  itemSize: ItemSize;\r\n  overscanCount?: number;\r\n  scrollOffset?: number;\r\n  scrollToIndex?: number;\r\n  scrollToAlignment?: ALIGNMENT;\r\n  scrollDirection?: DIRECTION;\r\n  stickyIndices?: number[];\r\n  style?: React.CSSProperties;\r\n  width?: number | string;\r\n  onItemsRendered?({ startIndex, stopIndex }: RenderedRows): void;\r\n  onScroll?(offset: number, event: Event): void;\r\n  renderItem(itemInfo: ItemInfo): React.ReactNode;\r\n}\r\n\r\nexport interface State {\r\n  offset: number;\r\n  scrollChangeReason: SCROLL_CHANGE_REASON;\r\n}\r\n\r\nconst STYLE_WRAPPER: CSSProperties = {\r\n  overflow: 'auto',\r\n  willChange: 'transform',\r\n  WebkitOverflowScrolling: 'touch'\r\n};\r\n\r\nconst STYLE_INNER: CSSProperties = {\r\n  position: 'relative',\r\n  width: '100%',\r\n  minHeight: '100%'\r\n};\r\n\r\nconst STYLE_ITEM: {\r\n  position: ItemStyle['position'];\r\n  top: ItemStyle['top'];\r\n  left: ItemStyle['left'];\r\n  width: ItemStyle['width'];\r\n} = {\r\n  position: 'absolute' as ItemPosition,\r\n  top: 0,\r\n  left: 0,\r\n  width: '100%'\r\n};\r\n\r\nconst STYLE_STICKY_ITEM = {\r\n  ...STYLE_ITEM,\r\n  position: 'sticky' as ItemPosition\r\n};\r\n\r\nexport default function VirtualList(props: Props) {\r\n  const {\r\n    estimatedItemSize,\r\n    height,\r\n    itemCount,\r\n    itemSize,\r\n    onItemsRendered,\r\n    onScroll,\r\n    overscanCount = 3,\r\n    renderItem,\r\n    scrollDirection = DIRECTION.VERTICAL,\r\n    scrollOffset,\r\n    scrollToAlignment,\r\n    scrollToIndex,\r\n    stickyIndices,\r\n    style,\r\n    width = '100%',\r\n    ...rest\r\n  } = props;\r\n\r\n  const useForceUpdate = () => {\r\n    const [, setState] = useState();\r\n    return () => setState({});\r\n  };\r\n\r\n  const forceUpdate = useForceUpdate();\r\n\r\n  const rootNodeRef = useRef<HTMLDivElement>(null);\r\n  const styleCacheRef = useRef<StyleCache>({});\r\n\r\n  const itemCountRef = useRef(0);\r\n\r\n  const getSize = (index: number, itemSize: ItemSize) => {\r\n    if (typeof itemSize === 'function') {\r\n      return itemSize(index);\r\n    }\r\n\r\n    return Array.isArray(itemSize) ? itemSize[index] : itemSize;\r\n  };\r\n\r\n  const itemSizeGetter = (itemSize: Props['itemSize']) => {\r\n    return (index: number) => getSize(index, itemSize);\r\n  };\r\n\r\n  const getEstimatedItemSize = () => {\r\n    return (\r\n      estimatedItemSize || (typeof itemSize === 'number' && itemSize) || 50\r\n    );\r\n  };\r\n  const sizeAndPositionManager = new SizeAndPositionManager({\r\n    itemCount: itemCount,\r\n    itemSizeGetter: itemSizeGetter(itemSize),\r\n    estimatedItemSize: getEstimatedItemSize()\r\n  });\r\n\r\n  const getOffsetForIndex = (\r\n    index: number,\r\n    newScrollToAlignment = scrollToAlignment,\r\n    newItemCount = itemCount\r\n  ): number => {\r\n    if (index < 0 || index >= newItemCount) {\r\n      index = 0;\r\n    }\r\n\r\n    return sizeAndPositionManager.getUpdatedOffsetForIndex({\r\n      align: newScrollToAlignment,\r\n      containerSize: Number(props[sizeProp[scrollDirection]]),\r\n      currentOffset: offset || 0,\r\n      targetIndex: index\r\n    });\r\n  };\r\n\r\n  const [offset, setOffset] = useState(\r\n    scrollOffset ||\r\n      (scrollToIndex != null && getOffsetForIndex(scrollToIndex)) ||\r\n      0\r\n  );\r\n  const [scrollChangeReason, setScrollChangeReason] = useState(\r\n    SCROLL_CHANGE_REASON.REQUESTED\r\n  );\r\n\r\n  const scrollTo = (value: number) => {\r\n    if (rootNodeRef.current) {\r\n      rootNodeRef.current[scrollProp[scrollDirection]] = value;\r\n    }\r\n  };\r\n\r\n  const getNodeOffset = () => {\r\n    if (rootNodeRef.current) {\r\n      return rootNodeRef.current[scrollProp[scrollDirection]];\r\n    }\r\n    return 0;\r\n  };\r\n\r\n  // const handleScroll = (event: Event) => {\r\n  //   const offset = getNodeOffset();\r\n\r\n  //   if (\r\n  //     offset < 0 ||\r\n  //     //   state.offset === offset ||\r\n  //     event.target !== rootNodeRef.current\r\n  //   ) {\r\n  //     return;\r\n  //   }\r\n\r\n  //   // setState({\r\n  //   //   offset,\r\n  //   //   scrollChangeReason: SCROLL_CHANGE_REASON.OBSERVED\r\n  //   // });\r\n  //   setScrollChangeReason(SCROLL_CHANGE_REASON.OBSERVED);\r\n  //   setOffset(offset);\r\n\r\n  //   if (typeof onScroll === \"function\") {\r\n  //     onScroll(offset, event);\r\n  //   }\r\n  // };\r\n  const handleScroll = (event: Event) => {\r\n    const newOffset = getNodeOffset();\r\n\r\n    if (\r\n      newOffset < 0 ||\r\n      newOffset === offset ||\r\n      event.target !== rootNodeRef.current\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    // setState({\r\n    //   offset,\r\n    //   scrollChangeReason: SCROLL_CHANGE_REASON.OBSERVED\r\n    // });\r\n    setScrollChangeReason(SCROLL_CHANGE_REASON.OBSERVED);\r\n    setOffset(newOffset);\r\n\r\n    if (typeof onScroll === 'function') {\r\n      onScroll(newOffset, event);\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (rootNodeRef.current) {\r\n      rootNodeRef.current.addEventListener('scroll', handleScroll, {\r\n        passive: true\r\n      });\r\n    }\r\n    if (scrollOffset != null) {\r\n      scrollTo(scrollOffset);\r\n    } else if (scrollToIndex != null) {\r\n      scrollTo(getOffsetForIndex(scrollToIndex));\r\n    }\r\n    return () => {\r\n      if (rootNodeRef.current) {\r\n        rootNodeRef.current.removeEventListener('scroll', handleScroll);\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  const recomputeSizes = (startIndex = 0) => {\r\n    styleCacheRef.current = {};\r\n    sizeAndPositionManager.resetItem(startIndex);\r\n  };\r\n\r\n  useEffect(() => {\r\n    sizeAndPositionManager.updateConfig({\r\n      itemSizeGetter: itemSizeGetter(itemSize)\r\n    });\r\n    recomputeSizes();\r\n  }, [itemSize]);\r\n\r\n  useEffect(() => {\r\n    setScrollChangeReason(SCROLL_CHANGE_REASON.REQUESTED);\r\n    setOffset(scrollOffset || 0);\r\n  }, [scrollOffset]);\r\n\r\n  useEffect(() => {\r\n    sizeAndPositionManager.updateConfig({\r\n      itemCount,\r\n      estimatedItemSize: getEstimatedItemSize()\r\n    });\r\n\r\n    recomputeSizes();\r\n\r\n    forceUpdate();\r\n  }, [itemCount, stickyIndices]);\r\n\r\n  useEffect(() => {\r\n    // const scrollPropsHaveChanged = true;\r\n    // const itemPropsHaveChanged = false;\r\n\r\n    if (typeof scrollToIndex === 'number') {\r\n      setOffset(getOffsetForIndex(scrollToIndex, scrollToAlignment, itemCount));\r\n      setScrollChangeReason(SCROLL_CHANGE_REASON.REQUESTED);\r\n      // setState({\r\n      //   offset: getOffsetForIndex(scrollToIndex, scrollToAlignment, itemCount),\r\n      //   scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\r\n      // });\r\n    }\r\n  }, [scrollToIndex, scrollToAlignment]);\r\n\r\n  useEffect(() => {\r\n    if (scrollChangeReason === SCROLL_CHANGE_REASON.REQUESTED) {\r\n      scrollTo(offset);\r\n    }\r\n  }, [offset]);\r\n\r\n  const getStyle = (index: number, sticky: boolean) => {\r\n    const style = styleCacheRef.current[index];\r\n\r\n    if (style) {\r\n      return style;\r\n    }\r\n\r\n    const { size, offset } = sizeAndPositionManager.getSizeAndPositionForIndex(\r\n      index\r\n    );\r\n\r\n    return (styleCacheRef.current[index] = sticky\r\n      ? {\r\n          ...STYLE_STICKY_ITEM,\r\n          [sizeProp[scrollDirection]]: size,\r\n\r\n          // [positionProp[scrollDirection]]: offset,\r\n          [marginProp[scrollDirection]]: offset,\r\n          [oppositeMarginProp[scrollDirection]]: -(offset + size),\r\n          zIndex: 1\r\n        }\r\n      : {\r\n          ...STYLE_ITEM,\r\n          [sizeProp[scrollDirection]]: size,\r\n          [positionProp[scrollDirection]]: offset\r\n        });\r\n  };\r\n\r\n  if (itemCountRef.current !== itemCount) {\r\n    sizeAndPositionManager.updateConfig({\r\n      itemCount,\r\n      estimatedItemSize: getEstimatedItemSize()\r\n    });\r\n\r\n    recomputeSizes();\r\n    itemCountRef.current = itemCount;\r\n  }\r\n  const { start, stop } = sizeAndPositionManager.getVisibleRange({\r\n    containerSize: Number(props[sizeProp[scrollDirection]]) || 0,\r\n    offset,\r\n    overscanCount\r\n  });\r\n  const items: React.ReactNode[] = [];\r\n  const wrapperStyle = { ...STYLE_WRAPPER, ...style, height, width };\r\n  const innerStyle = {\r\n    ...STYLE_INNER,\r\n    [sizeProp[scrollDirection]]: sizeAndPositionManager.getTotalSize()\r\n  };\r\n\r\n  if (stickyIndices != null && stickyIndices.length !== 0) {\r\n    stickyIndices.forEach((index: number) =>\r\n      items.push(\r\n        renderItem({\r\n          index,\r\n          style: getStyle(index, true)\r\n        })\r\n      )\r\n    );\r\n\r\n    if (scrollDirection === DIRECTION.HORIZONTAL) {\r\n      innerStyle.display = 'flex';\r\n    }\r\n  }\r\n\r\n  if (typeof start !== 'undefined' && typeof stop !== 'undefined') {\r\n    for (let index = start; index <= stop; index++) {\r\n      if (stickyIndices != null && stickyIndices.includes(index)) {\r\n        continue;\r\n      }\r\n\r\n      items.push(\r\n        renderItem({\r\n          index,\r\n          style: getStyle(index, false)\r\n        })\r\n      );\r\n    }\r\n\r\n    if (typeof onItemsRendered === 'function') {\r\n      onItemsRendered({\r\n        startIndex: start,\r\n        stopIndex: stop\r\n      });\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div ref={rootNodeRef} {...rest} style={wrapperStyle}>\r\n      <div style={innerStyle}>{items}</div>\r\n    </div>\r\n  );\r\n}\r\n","/* Forked from react-virtualized 💖 */\r\nimport { ALIGNMENT } from './constants';\r\n\r\nexport type ItemSizeGetter = (index: number) => number;\r\nexport type ItemSize = number | number[] | ItemSizeGetter;\r\n\r\nexport interface SizeAndPosition {\r\n  size: number;\r\n  offset: number;\r\n}\r\n\r\ninterface SizeAndPositionData {\r\n  [id: number]: SizeAndPosition;\r\n}\r\n\r\nexport interface Options {\r\n  itemCount: number;\r\n  itemSizeGetter: ItemSizeGetter;\r\n  estimatedItemSize: number;\r\n}\r\n\r\nexport default class SizeAndPositionManager {\r\n  private itemSizeGetter: ItemSizeGetter;\r\n  private itemCount: number;\r\n  private estimatedItemSize: number;\r\n  private lastMeasuredIndex: number;\r\n  private itemSizeAndPositionData: SizeAndPositionData;\r\n\r\n  constructor({ itemCount, itemSizeGetter, estimatedItemSize }: Options) {\r\n    this.itemSizeGetter = itemSizeGetter;\r\n    this.itemCount = itemCount;\r\n    this.estimatedItemSize = estimatedItemSize;\r\n\r\n    // Cache of size and position data for items, mapped by item index.\r\n    this.itemSizeAndPositionData = {};\r\n\r\n    // Measurements for items up to this index can be trusted; items afterward should be estimated.\r\n    this.lastMeasuredIndex = -1;\r\n  }\r\n\r\n  updateConfig({\r\n    itemCount,\r\n    itemSizeGetter,\r\n    estimatedItemSize\r\n  }: Partial<Options>) {\r\n    if (itemCount != null) {\r\n      this.itemCount = itemCount;\r\n    }\r\n\r\n    if (estimatedItemSize != null) {\r\n      this.estimatedItemSize = estimatedItemSize;\r\n    }\r\n\r\n    if (itemSizeGetter != null) {\r\n      this.itemSizeGetter = itemSizeGetter;\r\n    }\r\n  }\r\n\r\n  getLastMeasuredIndex() {\r\n    return this.lastMeasuredIndex;\r\n  }\r\n\r\n  /**\r\n   * This method returns the size and position for the item at the specified index.\r\n   * It just-in-time calculates (or used cached values) for items leading up to the index.\r\n   */\r\n  getSizeAndPositionForIndex(index: number) {\r\n    if (index < 0 || index >= this.itemCount) {\r\n      throw Error(\r\n        `Requested index ${index} is outside of range 0..${this.itemCount}`\r\n      );\r\n    }\r\n\r\n    if (index > this.lastMeasuredIndex) {\r\n      const lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\r\n      let offset =\r\n        lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size;\r\n\r\n      for (let i = this.lastMeasuredIndex + 1; i <= index; i++) {\r\n        const size = this.itemSizeGetter(i);\r\n\r\n        if (size == null || isNaN(size)) {\r\n          throw Error(`Invalid size returned for index ${i} of value ${size}`);\r\n        }\r\n\r\n        this.itemSizeAndPositionData[i] = {\r\n          offset,\r\n          size\r\n        };\r\n\r\n        offset += size;\r\n      }\r\n\r\n      this.lastMeasuredIndex = index;\r\n    }\r\n\r\n    return this.itemSizeAndPositionData[index];\r\n  }\r\n\r\n  getSizeAndPositionOfLastMeasuredItem() {\r\n    return this.lastMeasuredIndex >= 0\r\n      ? this.itemSizeAndPositionData[this.lastMeasuredIndex]\r\n      : { offset: 0, size: 0 };\r\n  }\r\n\r\n  /**\r\n   * Total size of all items being measured.\r\n   * This value will be completedly estimated initially.\r\n   * As items as measured the estimate will be updated.\r\n   */\r\n  getTotalSize(): number {\r\n    const lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\r\n\r\n    return (\r\n      lastMeasuredSizeAndPosition.offset +\r\n      lastMeasuredSizeAndPosition.size +\r\n      (this.itemCount - this.lastMeasuredIndex - 1) * this.estimatedItemSize\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Determines a new offset that ensures a certain item is visible, given the alignment.\r\n   *\r\n   * @param align Desired alignment within container; one of \"start\" (default), \"center\", or \"end\"\r\n   * @param containerSize Size (width or height) of the container viewport\r\n   * @return Offset to use to ensure the specified item is visible\r\n   */\r\n  getUpdatedOffsetForIndex({\r\n    align = ALIGNMENT.START,\r\n    containerSize,\r\n    currentOffset,\r\n    targetIndex\r\n  }: {\r\n    align: ALIGNMENT | undefined;\r\n    containerSize: number;\r\n    currentOffset: number;\r\n    targetIndex: number;\r\n  }): number {\r\n    if (containerSize <= 0) {\r\n      return 0;\r\n    }\r\n\r\n    const datum = this.getSizeAndPositionForIndex(targetIndex);\r\n    const maxOffset = datum.offset;\r\n    const minOffset = maxOffset - containerSize + datum.size;\r\n\r\n    let idealOffset;\r\n\r\n    switch (align) {\r\n      case ALIGNMENT.END:\r\n        idealOffset = minOffset;\r\n        break;\r\n      case ALIGNMENT.CENTER:\r\n        idealOffset = maxOffset - (containerSize - datum.size) / 2;\r\n        break;\r\n      case ALIGNMENT.START:\r\n        idealOffset = maxOffset;\r\n        break;\r\n      default:\r\n        idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));\r\n    }\r\n\r\n    const totalSize = this.getTotalSize();\r\n\r\n    return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\r\n  }\r\n\r\n  getVisibleRange({\r\n    containerSize,\r\n    offset,\r\n    overscanCount\r\n  }: {\r\n    containerSize: number;\r\n    offset: number;\r\n    overscanCount: number;\r\n  }): { start?: number; stop?: number } {\r\n    const totalSize = this.getTotalSize();\r\n\r\n    if (totalSize === 0) {\r\n      return {};\r\n    }\r\n\r\n    const maxOffset = offset + containerSize;\r\n    let start = this.findNearestItem(offset);\r\n\r\n    if (typeof start === 'undefined') {\r\n      throw Error(`Invalid offset ${offset} specified`);\r\n    }\r\n\r\n    const datum = this.getSizeAndPositionForIndex(start);\r\n    offset = datum.offset + datum.size;\r\n\r\n    let stop = start;\r\n\r\n    while (offset < maxOffset && stop < this.itemCount - 1) {\r\n      stop++;\r\n      offset += this.getSizeAndPositionForIndex(stop).size;\r\n    }\r\n\r\n    if (overscanCount) {\r\n      start = Math.max(0, start - overscanCount);\r\n      stop = Math.min(stop + overscanCount, this.itemCount - 1);\r\n    }\r\n\r\n    return {\r\n      start,\r\n      stop\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clear all cached values for items after the specified index.\r\n   * This method should be called for any item that has changed its size.\r\n   * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionForIndex() is called.\r\n   */\r\n  resetItem(index: number) {\r\n    this.lastMeasuredIndex = Math.min(this.lastMeasuredIndex, index - 1);\r\n  }\r\n\r\n  /**\r\n   * Searches for the item (index) nearest the specified offset.\r\n   *\r\n   * If no exact match is found the next lowest item index will be returned.\r\n   * This allows partially visible items (with offsets just before/above the fold) to be visible.\r\n   */\r\n  findNearestItem(offset: number) {\r\n    if (isNaN(offset)) {\r\n      throw Error(`Invalid offset ${offset} specified`);\r\n    }\r\n\r\n    // Our search algorithms find the nearest match at or below the specified offset.\r\n    // So make sure the offset is at least 0 or no match will be found.\r\n    offset = Math.max(0, offset);\r\n\r\n    const lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\r\n    const lastMeasuredIndex = Math.max(0, this.lastMeasuredIndex);\r\n\r\n    if (lastMeasuredSizeAndPosition.offset >= offset) {\r\n      // If we've already measured items within this range just use a binary search as it's faster.\r\n      return this.binarySearch({\r\n        high: lastMeasuredIndex,\r\n        low: 0,\r\n        offset\r\n      });\r\n    } else {\r\n      // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\r\n      // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\r\n      // The overall complexity for this approach is O(log n).\r\n      return this.exponentialSearch({\r\n        index: lastMeasuredIndex,\r\n        offset\r\n      });\r\n    }\r\n  }\r\n\r\n  private binarySearch({\r\n    low,\r\n    high,\r\n    offset\r\n  }: {\r\n    low: number;\r\n    high: number;\r\n    offset: number;\r\n  }) {\r\n    let middle = 0;\r\n    let currentOffset = 0;\r\n\r\n    while (low <= high) {\r\n      middle = low + Math.floor((high - low) / 2);\r\n      currentOffset = this.getSizeAndPositionForIndex(middle).offset;\r\n\r\n      if (currentOffset === offset) {\r\n        return middle;\r\n      } else if (currentOffset < offset) {\r\n        low = middle + 1;\r\n      } else if (currentOffset > offset) {\r\n        high = middle - 1;\r\n      }\r\n    }\r\n\r\n    if (low > 0) {\r\n      return low - 1;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  private exponentialSearch({\r\n    index,\r\n    offset\r\n  }: {\r\n    index: number;\r\n    offset: number;\r\n  }) {\r\n    let interval = 1;\r\n\r\n    while (\r\n      index < this.itemCount &&\r\n      this.getSizeAndPositionForIndex(index).offset < offset\r\n    ) {\r\n      index += interval;\r\n      interval *= 2;\r\n    }\r\n\r\n    return this.binarySearch({\r\n      high: Math.min(index, this.itemCount - 1),\r\n      low: Math.floor(index / 2),\r\n      offset\r\n    });\r\n  }\r\n}\r\n"],"sourceRoot":""}