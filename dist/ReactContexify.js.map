{"version":3,"sources":["webpack://ReactContexify/webpack/universalModuleDefinition","webpack://ReactContexify/webpack/bootstrap","webpack://ReactContexify/./src/components/constants.ts","webpack://ReactContexify/./src/index.ts","webpack://ReactContexify/./src/components/VirtualList.tsx","webpack://ReactContexify/external \"react\"","webpack://ReactContexify/./src/components/SizeAndPositionManager.ts"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__3__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","DIRECTION","ALIGNMENT","SCROLL_CHANGE_REASON","scrollProp","sizeProp","positionProp","_a","VERTICAL","HORIZONTAL","marginProp","_b","oppositeMarginProp","_c","VirtualList_1","VirtualList","default","constants_1","React","__importStar","SizeAndPositionManager_1","__importDefault","constants_2","ScrollDirection","STYLE_WRAPPER","overflow","willChange","WebkitOverflowScrolling","STYLE_INNER","position","width","minHeight","STYLE_ITEM","top","left","STYLE_STICKY_ITEM","__assign","useRef","useState","useEffect","props","forceUpdate","setState","useForceUpdate","rootNodeRef","styleCacheRef","itemCountRef","itemSizeGetter","itemSize","index","Array","isArray","getSize","getEstimatedItemSize","estimatedItemSize","sizeAndPositionManager","itemCount","getOffsetForIndex","scrollToAlignment","scrollDirection","getUpdatedOffsetForIndex","align","containerSize","Number","currentOffset","offset","targetIndex","state","scrollOffset","scrollToIndex","current","addEventListener","handleScroll","passive","scrollTo","removeEventListener","updateConfig","recomputeSizes","scrollChangeReason","REQUESTED","stickyIndices","startIndex","resetItem","event","onScroll","getNodeOffset","target","OBSERVED","getStyle","sticky","style","_d","getSizeAndPositionForIndex","size","zIndex","height","overscanCount","renderItem","onItemsRendered","rest","__rest","_e","getVisibleRange","start","stop","items","wrapperStyle","innerStyle","getTotalSize","length","forEach","push","display","includes","stopIndex","createElement","ref","defaultProps","SizeAndPositionManager","this","itemSizeAndPositionData","lastMeasuredIndex","getLastMeasuredIndex","Error","lastMeasuredSizeAndPosition","getSizeAndPositionOfLastMeasuredItem","isNaN","START","idealOffset","datum","maxOffset","minOffset","END","CENTER","Math","max","min","totalSize","findNearestItem","binarySearch","high","low","exponentialSearch","middle","floor","interval"],"mappings":"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","file":"ReactContexify.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactContexify\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"ReactContexify\"] = factory(root[\"react\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__3__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","export enum ALIGNMENT {\r\n  AUTO = 'auto',\r\n  START = 'start',\r\n  CENTER = 'center',\r\n  END = 'end'\r\n}\r\n\r\nexport enum DIRECTION {\r\n  HORIZONTAL = 'horizontal',\r\n  VERTICAL = 'vertical'\r\n}\r\n\r\nexport enum SCROLL_CHANGE_REASON {\r\n  OBSERVED = 'observed',\r\n  REQUESTED = 'requested'\r\n}\r\n\r\n// export const scrollProp = {\r\n//   [DIRECTION.VERTICAL]: 'scrollTop',\r\n//   [DIRECTION.HORIZONTAL]: 'scrollLeft',\r\n// };\r\n\r\n// export const scrollProp = {\r\n//   vertical: \"scrollTop\",\r\n//   horizontal: \"scrollLeft\"\r\n// };\r\n\r\nexport enum scrollProp {\r\n  vertical = 'scrollTop',\r\n  horizontal = 'scrollLeft'\r\n}\r\n\r\n// export const sizeProp = {\r\n//   [DIRECTION.VERTICAL]: \"height\",\r\n//   [DIRECTION.HORIZONTAL]: \"width\"\r\n// };\r\n\r\n// export const sizeProp = {\r\n//   vertical: \"height\",\r\n//   horizontal: \"width\"\r\n// };\r\n\r\nexport enum sizeProp {\r\n  vertical = 'height',\r\n  horizontal = 'width'\r\n}\r\n\r\nexport const positionProp = {\r\n  [DIRECTION.VERTICAL]: 'top',\r\n  [DIRECTION.HORIZONTAL]: 'left'\r\n};\r\n\r\nexport const marginProp = {\r\n  [DIRECTION.VERTICAL]: 'marginTop',\r\n  [DIRECTION.HORIZONTAL]: 'marginLeft'\r\n};\r\n\r\nexport const oppositeMarginProp = {\r\n  [DIRECTION.VERTICAL]: 'marginBottom',\r\n  [DIRECTION.HORIZONTAL]: 'marginRight'\r\n};\r\n","export { default as VirtualList } from './components/VirtualList';\nexport { ItemStyle } from './components/VirtualList';\nexport { ALIGNMENT } from './components/constants';\n","import * as React from 'react';\r\n// import * as PropTypes from \"prop-types\";\r\nimport SizeAndPositionManager, { ItemSize } from './SizeAndPositionManager';\r\nimport {\r\n  ALIGNMENT,\r\n  DIRECTION,\r\n  SCROLL_CHANGE_REASON,\r\n  marginProp,\r\n  oppositeMarginProp,\r\n  positionProp,\r\n  scrollProp,\r\n  sizeProp\r\n} from './constants';\r\n\r\nexport { DIRECTION as ScrollDirection } from './constants';\r\n\r\nexport type ItemPosition = 'absolute' | 'sticky';\r\n\r\nexport interface ItemStyle {\r\n  position: ItemPosition;\r\n  top?: number;\r\n  left: number;\r\n  width: string | number;\r\n  height?: number;\r\n  marginTop?: number;\r\n  marginLeft?: number;\r\n  marginRight?: number;\r\n  marginBottom?: number;\r\n  zIndex?: number;\r\n}\r\n\r\ninterface StyleCache {\r\n  [id: number]: ItemStyle;\r\n}\r\n\r\nexport interface ItemInfo {\r\n  index: number;\r\n  style: ItemStyle;\r\n}\r\n\r\nexport interface RenderedRows {\r\n  startIndex: number;\r\n  stopIndex: number;\r\n}\r\n\r\nexport interface Props {\r\n  className?: string;\r\n  estimatedItemSize?: number;\r\n  height: number | string;\r\n  itemCount: number;\r\n  itemSize: ItemSize;\r\n  overscanCount?: number;\r\n  scrollOffset?: number;\r\n  scrollToIndex?: number;\r\n  scrollToAlignment?: ALIGNMENT;\r\n  scrollDirection?: DIRECTION;\r\n  stickyIndices?: number[];\r\n  style?: React.CSSProperties;\r\n  width?: number | string;\r\n  onItemsRendered?({ startIndex, stopIndex }: RenderedRows): void;\r\n  onScroll?(offset: number, event: Event): void;\r\n  renderItem(itemInfo: ItemInfo): React.ReactNode;\r\n}\r\n\r\nexport interface State {\r\n  offset: number;\r\n  scrollChangeReason: SCROLL_CHANGE_REASON;\r\n}\r\n\r\nconst STYLE_WRAPPER: React.CSSProperties = {\r\n  overflow: 'auto',\r\n  willChange: 'transform',\r\n  WebkitOverflowScrolling: 'touch'\r\n};\r\n\r\nconst STYLE_INNER: React.CSSProperties = {\r\n  position: 'relative',\r\n  width: '100%',\r\n  minHeight: '100%'\r\n};\r\n\r\nconst STYLE_ITEM: {\r\n  position: ItemStyle['position'];\r\n  top: ItemStyle['top'];\r\n  left: ItemStyle['left'];\r\n  width: ItemStyle['width'];\r\n} = {\r\n  position: 'absolute' as ItemPosition,\r\n  top: 0,\r\n  left: 0,\r\n  width: '100%'\r\n};\r\n\r\nconst STYLE_STICKY_ITEM = {\r\n  ...STYLE_ITEM,\r\n  position: 'sticky' as ItemPosition\r\n};\r\n\r\nconst { useRef, useState, useEffect } = React;\r\n\r\nfunction VirtualList(props: Props) {\r\n  const useForceUpdate = () => {\r\n    const [, setState] = useState();\r\n    return () => setState({});\r\n  };\r\n\r\n  const forceUpdate = useForceUpdate();\r\n\r\n  const rootNodeRef = useRef<HTMLDivElement>(null);\r\n\r\n  const styleCacheRef = useRef<StyleCache>({});\r\n\r\n  const itemCountRef = useRef(0);\r\n  // static propTypes = {\r\n  //   estimatedItemSize: PropTypes.number,\r\n  //   height: PropTypes.oneOfType([PropTypes.number, PropTypes.string])\r\n  //     .isRequired,\r\n  //   itemCount: PropTypes.number.isRequired,\r\n  //   itemSize: PropTypes.oneOfType([\r\n  //     PropTypes.number,\r\n  //     PropTypes.array,\r\n  //     PropTypes.func\r\n  //   ]).isRequired,\r\n  //   onScroll: PropTypes.func,\r\n  //   onItemsRendered: PropTypes.func,\r\n  //   overscanCount: PropTypes.number,\r\n  //   renderItem: PropTypes.func.isRequired,\r\n  //   scrollOffset: PropTypes.number,\r\n  //   scrollToIndex: PropTypes.number,\r\n  //   scrollToAlignment: PropTypes.oneOf([\r\n  //     ALIGNMENT.AUTO,\r\n  //     ALIGNMENT.START,\r\n  //     ALIGNMENT.CENTER,\r\n  //     ALIGNMENT.END\r\n  //   ]),\r\n  //   scrollDirection: PropTypes.oneOf([\r\n  //     DIRECTION.HORIZONTAL,\r\n  //     DIRECTION.VERTICAL\r\n  //   ]),\r\n  //   stickyIndices: PropTypes.arrayOf(PropTypes.number),\r\n  //   style: PropTypes.object,\r\n  //   width: PropTypes.oneOfType([PropTypes.number, PropTypes.string])\r\n  // };\r\n\r\n  const getSize = (\r\n    index: number,\r\n    itemSize: number | number[] | ((index: number) => number)\r\n  ) => {\r\n    if (typeof itemSize === 'function') {\r\n      return itemSize(index);\r\n    }\r\n\r\n    return Array.isArray(itemSize) ? itemSize[index] : itemSize;\r\n  };\r\n\r\n  const itemSizeGetter = (itemSize: Props['itemSize']) => {\r\n    return (index: number) => getSize(index, itemSize);\r\n  };\r\n  const getEstimatedItemSize = (props: Props /*props = this.props*/) => {\r\n    return (\r\n      props.estimatedItemSize ||\r\n      (typeof props.itemSize === 'number' && props.itemSize) ||\r\n      50\r\n    );\r\n  };\r\n  const sizeAndPositionManager = new SizeAndPositionManager({\r\n    itemCount: props.itemCount,\r\n    itemSizeGetter: itemSizeGetter(props.itemSize),\r\n    estimatedItemSize: getEstimatedItemSize(props)\r\n  });\r\n\r\n  const getOffsetForIndex = (\r\n    index: number,\r\n    scrollToAlignment = props.scrollToAlignment,\r\n    itemCount: number = props.itemCount\r\n  ): number => {\r\n    const { scrollDirection = DIRECTION.VERTICAL } = props;\r\n\r\n    if (index < 0 || index >= itemCount) {\r\n      index = 0;\r\n    }\r\n\r\n    return sizeAndPositionManager.getUpdatedOffsetForIndex({\r\n      align: scrollToAlignment,\r\n      containerSize: Number(props[sizeProp[scrollDirection]]),\r\n      currentOffset: offset || 0,\r\n      targetIndex: index\r\n    });\r\n  };\r\n\r\n  const [state, setState] = useState({\r\n    offset:\r\n      props.scrollOffset ||\r\n      (props.scrollToIndex != null && getOffsetForIndex(props.scrollToIndex)) ||\r\n      0,\r\n    scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\r\n  });\r\n\r\n  // const [offset, setOffset] = useState(\r\n  //   props.scrollOffset ||\r\n  //     (props.scrollToIndex != null && getOffsetForIndex(props.scrollToIndex)) ||\r\n  //     0\r\n  // );\r\n\r\n  // const [scrollChangeReason, setScrollChangeReason] = useState(\r\n  //   SCROLL_CHANGE_REASON.REQUESTED\r\n  // );\r\n\r\n  // const state: State = {\r\n  //   offset:\r\n  //     props.scrollOffset ||\r\n  //     (props.scrollToIndex != null && getOffsetForIndex(props.scrollToIndex)) ||\r\n  //     0,\r\n  //   scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\r\n  // };\r\n  // const componentDidMount = () => {\r\n  useEffect(() => {\r\n    const { scrollOffset, scrollToIndex } = props;\r\n    rootNodeRef.current!.addEventListener('scroll', handleScroll, {\r\n      passive: true\r\n    });\r\n\r\n    if (scrollOffset != null) {\r\n      scrollTo(scrollOffset);\r\n    } else if (scrollToIndex != null) {\r\n      scrollTo(getOffsetForIndex(scrollToIndex));\r\n    }\r\n    return () => {\r\n      rootNodeRef.current!.removeEventListener('scroll', handleScroll);\r\n    };\r\n  }, []);\r\n\r\n  // const componentWillReceiveProps = (nextProps: Props) => {\r\n  //   const {\r\n  //     estimatedItemSize,\r\n  //     itemCount,\r\n  //     itemSize,\r\n  //     scrollOffset,\r\n  //     scrollToAlignment,\r\n  //     scrollToIndex\r\n  //   } = props;\r\n  //   const scrollPropsHaveChanged =\r\n  //     nextProps.scrollToIndex !== scrollToIndex ||\r\n  //     nextProps.scrollToAlignment !== scrollToAlignment;\r\n  //   const itemPropsHaveChanged =\r\n  //     nextProps.itemCount !== itemCount ||\r\n  //     nextProps.itemSize !== itemSize ||\r\n  //     nextProps.estimatedItemSize !== estimatedItemSize;\r\n\r\n  //   if (nextProps.itemSize !== itemSize) {\r\n  //     sizeAndPositionManager.updateConfig({\r\n  //       itemSizeGetter: itemSizeGetter(nextProps.itemSize)\r\n  //     });\r\n  //   }\r\n\r\n  //   if (\r\n  //     nextProps.itemCount !== itemCount ||\r\n  //     nextProps.estimatedItemSize !== estimatedItemSize\r\n  //   ) {\r\n  //     sizeAndPositionManager.updateConfig({\r\n  //       itemCount: nextProps.itemCount,\r\n  //       estimatedItemSize: getEstimatedItemSize(nextProps)\r\n  //     });\r\n  //   }\r\n\r\n  //   if (itemPropsHaveChanged) {\r\n  //     recomputeSizes();\r\n  //   }\r\n\r\n  //   if (nextProps.scrollOffset !== scrollOffset) {\r\n  //     setOffset(nextProps.scrollOffset || 0);\r\n  //     setScrollChangeReason(SCROLL_CHANGE_REASON.REQUESTED);\r\n  //   } else if (\r\n  //     typeof nextProps.scrollToIndex === \"number\" &&\r\n  //     (scrollPropsHaveChanged || itemPropsHaveChanged)\r\n  //   ) {\r\n  //     setOffset(\r\n  //       getOffsetForIndex(\r\n  //         nextProps.scrollToIndex,\r\n  //         nextProps.scrollToAlignment,\r\n  //         nextProps.itemCount\r\n  //       )\r\n  //     );\r\n  //     setScrollChangeReason(SCROLL_CHANGE_REASON.REQUESTED);\r\n  //   }\r\n  // };\r\n\r\n  useEffect(() => {\r\n    const { itemSize } = props;\r\n    sizeAndPositionManager.updateConfig({\r\n      itemSizeGetter: itemSizeGetter(itemSize)\r\n    });\r\n    recomputeSizes();\r\n  }, [props.itemSize]);\r\n\r\n  useEffect(() => {\r\n    setState({\r\n      offset: props.scrollOffset || 0,\r\n      scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\r\n    });\r\n  }, [props.scrollOffset]);\r\n\r\n  useEffect(() => {\r\n    const { itemCount } = props;\r\n\r\n    sizeAndPositionManager.updateConfig({\r\n      itemCount,\r\n      estimatedItemSize: getEstimatedItemSize(props)\r\n    });\r\n\r\n    recomputeSizes();\r\n\r\n    forceUpdate();\r\n  }, [props.itemCount, props.stickyIndices]);\r\n\r\n  useEffect(() => {\r\n    // const { scrollToIndex, scrollToAlignment, itemCount } = props;\r\n    // const scrollPropsHaveChanged = true;\r\n    // const itemPropsHaveChanged = false;\r\n\r\n    if (typeof scrollToIndex === 'number') {\r\n      setState({\r\n        offset: getOffsetForIndex(scrollToIndex, scrollToAlignment, itemCount),\r\n        scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\r\n      });\r\n    }\r\n  }, [props.scrollToIndex, props.scrollToAlignment]);\r\n\r\n  // const componentDidUpdate = (_: Props, prevState: State) => {\r\n  //   // const { offset, scrollChangeReason } = state;\r\n\r\n  //   if (\r\n  //     prevState.offset !== offset &&\r\n  //     scrollChangeReason === SCROLL_CHANGE_REASON.REQUESTED\r\n  //   ) {\r\n  //     scrollTo(offset);\r\n  //   }\r\n  // };\r\n\r\n  useEffect(() => {\r\n    const { offset, scrollChangeReason } = state;\r\n    if (scrollChangeReason === SCROLL_CHANGE_REASON.REQUESTED) {\r\n      scrollTo(offset);\r\n    }\r\n  }, [state.offset]);\r\n\r\n  const scrollTo = (value: number) => {\r\n    const { scrollDirection = DIRECTION.VERTICAL } = props;\r\n\r\n    rootNodeRef.current![scrollProp[scrollDirection]] = value;\r\n  };\r\n\r\n  const recomputeSizes = (startIndex = 0) => {\r\n    styleCacheRef.current = {};\r\n    sizeAndPositionManager.resetItem(startIndex);\r\n  };\r\n\r\n  // const getRef = (node: HTMLDivElement): void => {\r\n  //   rootNode = node;\r\n  // };\r\n\r\n  const handleScroll = (event: Event) => {\r\n    const { onScroll } = props;\r\n    const offset = getNodeOffset();\r\n\r\n    if (\r\n      offset < 0 ||\r\n      //   state.offset === offset ||\r\n      event.target !== rootNodeRef.current\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    setState({\r\n      offset,\r\n      scrollChangeReason: SCROLL_CHANGE_REASON.OBSERVED\r\n    });\r\n\r\n    if (typeof onScroll === 'function') {\r\n      onScroll(offset, event);\r\n    }\r\n  };\r\n\r\n  const getNodeOffset = () => {\r\n    const { scrollDirection = DIRECTION.VERTICAL } = props;\r\n\r\n    return rootNodeRef.current![scrollProp[scrollDirection]];\r\n  };\r\n\r\n  const getStyle = (index: number, sticky: boolean) => {\r\n    const style = styleCacheRef.current[index];\r\n\r\n    if (style) {\r\n      return style;\r\n    }\r\n\r\n    const { scrollDirection = DIRECTION.VERTICAL } = props;\r\n    const { size, offset } = sizeAndPositionManager.getSizeAndPositionForIndex(\r\n      index\r\n    );\r\n\r\n    return (styleCacheRef.current[index] = sticky\r\n      ? {\r\n          ...STYLE_STICKY_ITEM,\r\n          [sizeProp[scrollDirection]]: size,\r\n\r\n          // [positionProp[scrollDirection]]: offset,\r\n          [marginProp[scrollDirection]]: offset,\r\n          [oppositeMarginProp[scrollDirection]]: -(offset + size),\r\n          zIndex: 1\r\n        }\r\n      : {\r\n          ...STYLE_ITEM,\r\n          [sizeProp[scrollDirection]]: size,\r\n          [positionProp[scrollDirection]]: offset\r\n        });\r\n  };\r\n  // render() {\r\n  const {\r\n    estimatedItemSize,\r\n    height,\r\n    overscanCount = 3,\r\n    renderItem,\r\n    itemCount,\r\n    itemSize,\r\n    onItemsRendered,\r\n    onScroll,\r\n    scrollDirection = DIRECTION.VERTICAL,\r\n    scrollOffset,\r\n    scrollToIndex,\r\n    scrollToAlignment,\r\n    stickyIndices,\r\n    style,\r\n    width,\r\n    ...rest\r\n  } = props;\r\n\r\n  if (itemCountRef.current !== itemCount) {\r\n    sizeAndPositionManager.updateConfig({\r\n      itemCount,\r\n      estimatedItemSize: getEstimatedItemSize(props)\r\n    });\r\n\r\n    recomputeSizes();\r\n    itemCountRef.current = itemCount;\r\n  }\r\n  const { offset } = state;\r\n  const { start, stop } = sizeAndPositionManager.getVisibleRange({\r\n    containerSize: Number(props[sizeProp[scrollDirection]]) || 0,\r\n    offset,\r\n    overscanCount\r\n  });\r\n  const items: React.ReactNode[] = [];\r\n  const wrapperStyle = { ...STYLE_WRAPPER, ...style, height, width };\r\n  const innerStyle = {\r\n    ...STYLE_INNER,\r\n    [sizeProp[scrollDirection]]: sizeAndPositionManager.getTotalSize()\r\n  };\r\n\r\n  if (stickyIndices != null && stickyIndices.length !== 0) {\r\n    stickyIndices.forEach((index: number) =>\r\n      items.push(\r\n        renderItem({\r\n          index,\r\n          style: getStyle(index, true)\r\n        })\r\n      )\r\n    );\r\n\r\n    if (scrollDirection === DIRECTION.HORIZONTAL) {\r\n      innerStyle.display = 'flex';\r\n    }\r\n  }\r\n\r\n  if (typeof start !== 'undefined' && typeof stop !== 'undefined') {\r\n    for (let index = start; index <= stop; index++) {\r\n      if (stickyIndices != null && stickyIndices.includes(index)) {\r\n        continue;\r\n      }\r\n\r\n      items.push(\r\n        renderItem({\r\n          index,\r\n          style: getStyle(index, false)\r\n        })\r\n      );\r\n    }\r\n\r\n    if (typeof onItemsRendered === 'function') {\r\n      onItemsRendered({\r\n        startIndex: start,\r\n        stopIndex: stop\r\n      });\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div ref={rootNodeRef} {...rest} style={wrapperStyle}>\r\n      <div style={innerStyle}>{items}</div>\r\n    </div>\r\n  );\r\n}\r\n\r\nVirtualList.defaultProps = {\r\n  overscanCount: 3,\r\n  scrollDirection: DIRECTION.VERTICAL,\r\n  width: '100%'\r\n};\r\n\r\nexport default VirtualList;\r\n","module.exports = __WEBPACK_EXTERNAL_MODULE__3__;","/* Forked from react-virtualized 💖 */\r\nimport { ALIGNMENT } from './constants';\r\n\r\nexport type ItemSizeGetter = (index: number) => number;\r\nexport type ItemSize = number | number[] | ItemSizeGetter;\r\n\r\nexport interface SizeAndPosition {\r\n  size: number;\r\n  offset: number;\r\n}\r\n\r\ninterface SizeAndPositionData {\r\n  [id: number]: SizeAndPosition;\r\n}\r\n\r\nexport interface Options {\r\n  itemCount: number;\r\n  itemSizeGetter: ItemSizeGetter;\r\n  estimatedItemSize: number;\r\n}\r\n\r\nexport default class SizeAndPositionManager {\r\n  private itemSizeGetter: ItemSizeGetter;\r\n  private itemCount: number;\r\n  private estimatedItemSize: number;\r\n  private lastMeasuredIndex: number;\r\n  private itemSizeAndPositionData: SizeAndPositionData;\r\n\r\n  constructor({ itemCount, itemSizeGetter, estimatedItemSize }: Options) {\r\n    this.itemSizeGetter = itemSizeGetter;\r\n    this.itemCount = itemCount;\r\n    this.estimatedItemSize = estimatedItemSize;\r\n\r\n    // Cache of size and position data for items, mapped by item index.\r\n    this.itemSizeAndPositionData = {};\r\n\r\n    // Measurements for items up to this index can be trusted; items afterward should be estimated.\r\n    this.lastMeasuredIndex = -1;\r\n  }\r\n\r\n  updateConfig({\r\n    itemCount,\r\n    itemSizeGetter,\r\n    estimatedItemSize\r\n  }: Partial<Options>) {\r\n    if (itemCount != null) {\r\n      this.itemCount = itemCount;\r\n    }\r\n\r\n    if (estimatedItemSize != null) {\r\n      this.estimatedItemSize = estimatedItemSize;\r\n    }\r\n\r\n    if (itemSizeGetter != null) {\r\n      this.itemSizeGetter = itemSizeGetter;\r\n    }\r\n  }\r\n\r\n  getLastMeasuredIndex() {\r\n    return this.lastMeasuredIndex;\r\n  }\r\n\r\n  /**\r\n   * This method returns the size and position for the item at the specified index.\r\n   * It just-in-time calculates (or used cached values) for items leading up to the index.\r\n   */\r\n  getSizeAndPositionForIndex(index: number) {\r\n    if (index < 0 || index >= this.itemCount) {\r\n      throw Error(\r\n        `Requested index ${index} is outside of range 0..${this.itemCount}`\r\n      );\r\n    }\r\n\r\n    if (index > this.lastMeasuredIndex) {\r\n      const lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\r\n      let offset =\r\n        lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size;\r\n\r\n      for (let i = this.lastMeasuredIndex + 1; i <= index; i++) {\r\n        const size = this.itemSizeGetter(i);\r\n\r\n        if (size == null || isNaN(size)) {\r\n          throw Error(`Invalid size returned for index ${i} of value ${size}`);\r\n        }\r\n\r\n        this.itemSizeAndPositionData[i] = {\r\n          offset,\r\n          size\r\n        };\r\n\r\n        offset += size;\r\n      }\r\n\r\n      this.lastMeasuredIndex = index;\r\n    }\r\n\r\n    return this.itemSizeAndPositionData[index];\r\n  }\r\n\r\n  getSizeAndPositionOfLastMeasuredItem() {\r\n    return this.lastMeasuredIndex >= 0\r\n      ? this.itemSizeAndPositionData[this.lastMeasuredIndex]\r\n      : { offset: 0, size: 0 };\r\n  }\r\n\r\n  /**\r\n   * Total size of all items being measured.\r\n   * This value will be completedly estimated initially.\r\n   * As items as measured the estimate will be updated.\r\n   */\r\n  getTotalSize(): number {\r\n    const lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\r\n\r\n    return (\r\n      lastMeasuredSizeAndPosition.offset +\r\n      lastMeasuredSizeAndPosition.size +\r\n      (this.itemCount - this.lastMeasuredIndex - 1) * this.estimatedItemSize\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Determines a new offset that ensures a certain item is visible, given the alignment.\r\n   *\r\n   * @param align Desired alignment within container; one of \"start\" (default), \"center\", or \"end\"\r\n   * @param containerSize Size (width or height) of the container viewport\r\n   * @return Offset to use to ensure the specified item is visible\r\n   */\r\n  getUpdatedOffsetForIndex({\r\n    align = ALIGNMENT.START,\r\n    containerSize,\r\n    currentOffset,\r\n    targetIndex\r\n  }: {\r\n    align: ALIGNMENT | undefined;\r\n    containerSize: number;\r\n    currentOffset: number;\r\n    targetIndex: number;\r\n  }): number {\r\n    if (containerSize <= 0) {\r\n      return 0;\r\n    }\r\n\r\n    const datum = this.getSizeAndPositionForIndex(targetIndex);\r\n    const maxOffset = datum.offset;\r\n    const minOffset = maxOffset - containerSize + datum.size;\r\n\r\n    let idealOffset;\r\n\r\n    switch (align) {\r\n      case ALIGNMENT.END:\r\n        idealOffset = minOffset;\r\n        break;\r\n      case ALIGNMENT.CENTER:\r\n        idealOffset = maxOffset - (containerSize - datum.size) / 2;\r\n        break;\r\n      case ALIGNMENT.START:\r\n        idealOffset = maxOffset;\r\n        break;\r\n      default:\r\n        idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));\r\n    }\r\n\r\n    const totalSize = this.getTotalSize();\r\n\r\n    return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\r\n  }\r\n\r\n  getVisibleRange({\r\n    containerSize,\r\n    offset,\r\n    overscanCount\r\n  }: {\r\n    containerSize: number;\r\n    offset: number;\r\n    overscanCount: number;\r\n  }): { start?: number; stop?: number } {\r\n    const totalSize = this.getTotalSize();\r\n\r\n    if (totalSize === 0) {\r\n      return {};\r\n    }\r\n\r\n    const maxOffset = offset + containerSize;\r\n    let start = this.findNearestItem(offset);\r\n\r\n    if (typeof start === 'undefined') {\r\n      throw Error(`Invalid offset ${offset} specified`);\r\n    }\r\n\r\n    const datum = this.getSizeAndPositionForIndex(start);\r\n    offset = datum.offset + datum.size;\r\n\r\n    let stop = start;\r\n\r\n    while (offset < maxOffset && stop < this.itemCount - 1) {\r\n      stop++;\r\n      offset += this.getSizeAndPositionForIndex(stop).size;\r\n    }\r\n\r\n    if (overscanCount) {\r\n      start = Math.max(0, start - overscanCount);\r\n      stop = Math.min(stop + overscanCount, this.itemCount - 1);\r\n    }\r\n\r\n    return {\r\n      start,\r\n      stop\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clear all cached values for items after the specified index.\r\n   * This method should be called for any item that has changed its size.\r\n   * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionForIndex() is called.\r\n   */\r\n  resetItem(index: number) {\r\n    this.lastMeasuredIndex = Math.min(this.lastMeasuredIndex, index - 1);\r\n  }\r\n\r\n  /**\r\n   * Searches for the item (index) nearest the specified offset.\r\n   *\r\n   * If no exact match is found the next lowest item index will be returned.\r\n   * This allows partially visible items (with offsets just before/above the fold) to be visible.\r\n   */\r\n  findNearestItem(offset: number) {\r\n    if (isNaN(offset)) {\r\n      throw Error(`Invalid offset ${offset} specified`);\r\n    }\r\n\r\n    // Our search algorithms find the nearest match at or below the specified offset.\r\n    // So make sure the offset is at least 0 or no match will be found.\r\n    offset = Math.max(0, offset);\r\n\r\n    const lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\r\n    const lastMeasuredIndex = Math.max(0, this.lastMeasuredIndex);\r\n\r\n    if (lastMeasuredSizeAndPosition.offset >= offset) {\r\n      // If we've already measured items within this range just use a binary search as it's faster.\r\n      return this.binarySearch({\r\n        high: lastMeasuredIndex,\r\n        low: 0,\r\n        offset\r\n      });\r\n    } else {\r\n      // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\r\n      // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\r\n      // The overall complexity for this approach is O(log n).\r\n      return this.exponentialSearch({\r\n        index: lastMeasuredIndex,\r\n        offset\r\n      });\r\n    }\r\n  }\r\n\r\n  private binarySearch({\r\n    low,\r\n    high,\r\n    offset\r\n  }: {\r\n    low: number;\r\n    high: number;\r\n    offset: number;\r\n  }) {\r\n    let middle = 0;\r\n    let currentOffset = 0;\r\n\r\n    while (low <= high) {\r\n      middle = low + Math.floor((high - low) / 2);\r\n      currentOffset = this.getSizeAndPositionForIndex(middle).offset;\r\n\r\n      if (currentOffset === offset) {\r\n        return middle;\r\n      } else if (currentOffset < offset) {\r\n        low = middle + 1;\r\n      } else if (currentOffset > offset) {\r\n        high = middle - 1;\r\n      }\r\n    }\r\n\r\n    if (low > 0) {\r\n      return low - 1;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  private exponentialSearch({\r\n    index,\r\n    offset\r\n  }: {\r\n    index: number;\r\n    offset: number;\r\n  }) {\r\n    let interval = 1;\r\n\r\n    while (\r\n      index < this.itemCount &&\r\n      this.getSizeAndPositionForIndex(index).offset < offset\r\n    ) {\r\n      index += interval;\r\n      interval *= 2;\r\n    }\r\n\r\n    return this.binarySearch({\r\n      high: Math.min(index, this.itemCount - 1),\r\n      low: Math.floor(index / 2),\r\n      offset\r\n    });\r\n  }\r\n}\r\n"],"sourceRoot":""}